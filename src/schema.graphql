enum PIECE { r n b q k }
enum COLOR { w b }
enum FLAG { n b e c p k q }
enum SQUARE {
  a8 b8 c8 d8 e8 f8 g8 h8
  a7 b7 c7 d7 e7 f7 g7 h7
  a6 b6 c6 d6 e6 f6 g6 h6
  a5 b5 c5 d5 e5 f5 g5 h5
  a4 b4 c4 d4 e4 f4 g4 h4
  a3 b3 c3 d3 e3 f3 g3 h3
  a2 b2 c2 d2 e2 f2 g2 h2
  a1 b1 c1 d1 e1 f1 g1 h1
}

type Flags {
  NORMAL: FLAG,
  CAPTURE: FLAG,
  BIG_PAWN: FLAG,
  EP_CAPTURE: FLAG,
  PROMOTION: FLAG,
  KSIDE_CASTLE: FLAG,
  QSIDE_CASTLE: FLAG
}

type Constants {
  BISHOP: PIECE,
  BLACK: COLOR,
  FLAGS: Flags,
  KING: PIECE,
  KNIGHT: PIECE,
  PAWN: PIECE,
  QUEEN: PIECE,
  ROOK: PIECE,
  SQUARES: [SQUARE],
  WHITE: COLOR
}

type Move {
  captured: PIECE
  color: COLOR
  from: SQUARE!
  flags: String
  piece: PIECE
  promotion: PIECE
  san: String
  to: SQUARE!
}

type Game {
  ascii: String
  bestMove: String
  constants: Constants
  fen: String
  gameOver: Boolean
  inCheck: Boolean
  inCheckmate: Boolean
  inDraw: Boolean
  inStalemate: Boolean
  inThreefoldRepetition: Boolean
  insufficientMaterial: Boolean
  moves: [Move]
  turn: COLOR
}

type Query {
  game(fen: String): Game
}

input MoveInput {
  from: SQUARE!
  to: SQUARE!
  promotion: PIECE
}

input MakeMoveInput {
  fen: String!
  move: MoveInput!
}

type Mutation {
  makeMove(input: MakeMoveInput): Game
}
